---
title: "In-Sample Kelly Criterion Portfolio Replication"
subtitle: "Carta & Conversano (2020) - Figures 4 & 5, Tables 6 & 7"
author: "Replication Study"
date: "`r Sys.Date()`"
format:
   pdf:
    toc: true
    toc-depth: 3
    code-fold: show
    theme: cosmo
    fig-width: 10
    fig-height: 6
execute:
  warning: false
  message: false
---

# Overview

This document replicates **Section 3.2.2** of Carta & Conversano (2020): "Practical Implementation of the Kelly Criterion: Optimal Growth Rate, Number of Trades, and Rebalancing Frequency for Equity Portfolios"

**Key Outputs:**
- **Figure 4**: Efficient Frontier with optimal portfolios
- **Figure 5**: In-sample cumulative returns (2000-2018)
- **Table 6**: Tangent Portfolio composition
- **Table 7**: Kelly Portfolio composition

# Setup

```{r setup}
#| label: setup
#| include: true

# Load required packages
library(tidyverse)
library(quantmod)
library(lubridate)
library(scales)
library(knitr)
library(quadprog)
library(Matrix)

# Set options
options(scipen = 999)
theme_set(theme_minimal())
```

# 1. Data Download & Preparation

## 1.1 EuroStoxx 50 Tickers (Complete 42 Equities)

```{r tickers}
#| label: define-tickers

# Complete 42 equities used in Carta & Conversano (2020)
eurostoxx_tickers <- c(
  "AD.AS",      # Adidas
  "AI.PA",      # Air Liquide
  "ALV.DE",     # Allianz
  "AXA.PA",     # Axa
  "ISP.MI",     # Intesa Sanpaolo (Banca Intesa)
  "BAS.DE",     # BASF
  "BAYN.DE",    # Bayer
  "BBVA.MC",    # BBVA
  "BMW.DE",     # BMW
  "BNP.PA",     # BNP Paribas
  "CA.PA",      # Carrefour
  "CRH.IR",     # CRH
  "DBK.DE",     # Deutsche Bank
  "DTE.DE",     # Deutsche Telekom
  "ENEL.MI",    # Enel
  "ENGI.PA",    # Engie
  "ENI.MI",     # Eni
  "EOAN.DE",    # E.ON
  "G.MI",       # Generali
  "IBE.MC",     # Iberdrola
  "KER.PA",     # Kering
  "LVMH.PA",    # LVMH
  "OR.PA",      # L'Oréal
  "ORA.PA",     # Orange
  "PHIA.AS",    # Philips
  "SAF.PA",     # Safran
  "SAN.PA",     # Sanofi
  "SAN.MC",     # Santander
  "SAP.DE",     # SAP
  "SU.PA",      # Schneider Electric
  "SIE.DE",     # Siemens
  "FP.PA",      # TotalEnergies
  "TEF.MC",     # Telefonica
  "URW.AS",     # Unibail Rodamco Westfield
  "UNA.AS",     # Unilever
  "VIV.PA",     # Vivendi
  "DG.PA",      # Vinci
  "BN.PA",      # Danone
  "ITX.MC",     # Inditex
  "MUV2.DE",    # Munich Re (Muenchener Ruck)
  "NOKIA.HE",   # Nokia
  "VOW3.DE"     # Volkswagen
)

eurostoxx_tickers <- unique(eurostoxx_tickers)
cat("Total tickers to download:", length(eurostoxx_tickers), "\n")
```

## 1.2 Download Data from Yahoo Finance

```{r download-data}
#| label: download-data
#| cache: true

start_date <- as.Date("2000-01-01")
end_date <- as.Date("2018-12-31")

cat("Downloading EuroStoxx 50 data from Yahoo Finance...\n")
cat("Date range:", as.character(start_date), "to", as.character(end_date), "\n\n")

safe_download <- function(ticker, start, end) {
  tryCatch({
    data <- getSymbols(ticker, src = "yahoo", from = start, to = end, 
                       auto.assign = FALSE, warnings = FALSE)
    if (! is.null(data) && nrow(data) > 0) {
      adj_close <- Ad(data)
      colnames(adj_close) <- ticker
      return(adj_close)
    } else {
      return(NULL)
    }
  }, error = function(e) {
    message(paste("Failed to download:", ticker))
    return(NULL)
  })
}

price_data_list <- list()
successful_tickers <- c()
failed_tickers <- c()

for (ticker in eurostoxx_tickers) {
  cat("Downloading:", ticker, "...")
  data <- safe_download(ticker, start_date, end_date)
  
  if (!is.null(data)) {
    price_data_list[[ticker]] <- data
    successful_tickers <- c(successful_tickers, ticker)
    cat(" ✓\n")
  } else {
    failed_tickers <- c(failed_tickers, ticker)
    cat(" ✗\n")
  }
  
  Sys.sleep(0.5)
}

cat("\n")
cat("Successfully downloaded:", length(successful_tickers), "tickers\n")
cat("Failed downloads:", length(failed_tickers), "tickers\n")

if (length(failed_tickers) > 0) {
  cat("Failed tickers:", paste(failed_tickers, collapse = ", "), "\n")
}
```

## 1.3 Merge and Clean Data

```{r merge-data}
#| label: merge-data

if (length(price_data_list) > 0) {
  prices <- do.call(merge, price_data_list)
  
  # Remove columns with too many NAs (>20%)
  na_pct <- colMeans(is.na(prices))
  keep_cols <- na_pct < 0.20
  prices <- prices[, keep_cols]
  
  cat("After removing high-NA columns:", ncol(prices), "stocks remain\n")
  
  # Forward fill remaining NAs
  prices <- na.locf(prices, na.rm = FALSE)
  
  # Remove any remaining rows with NAs
  prices <- prices[complete.cases(prices), ]
  
  cat("Final dataset dimensions:", nrow(prices), "days ×", ncol(prices), "stocks\n")
  cat("Date range:", as.character(min(index(prices))), "to", 
      as.character(max(index(prices))), "\n")
} else {
  stop("No data downloaded successfully!")
}
```

## 1.4 Calculate Monthly Returns

```{r calculate-returns}
#| label: calculate-returns

# Convert to monthly data (end of month)
prices_monthly <- to.monthly(prices, OHLC = FALSE)

# Calculate log returns
returns_monthly <- diff(log(prices_monthly))
returns_monthly <- na.omit(returns_monthly)

# Convert to data frame
returns_df <- data.frame(
  DATE = index(returns_monthly),
  coredata(returns_monthly)
)

colnames(returns_df) <- c("DATE", colnames(returns_monthly))

cat("Monthly returns dataset:\n")
cat("  Observations:", nrow(returns_df), "months\n")
cat("  Assets:", ncol(returns_df) - 1, "\n")
cat("  Period:", format(min(returns_df$DATE), "%Y-%m"), "to", 
    format(max(returns_df$DATE), "%Y-%m"), "\n")

head(returns_df[, 1:5])
```

# 2.  Optimization Functions

## 2.1 Kelly Criterion (Long-Only, Constrained)

```{r kelly-optimization}
#| label: kelly-function

optimize_kelly_constrained <- function(returns_matrix, risk_free_rate = 0.01) {
  
  ret_mat <- returns_matrix %>%
    select(-DATE) %>%
    as.matrix()
  
  n_assets <- ncol(ret_mat)
  mean_returns <- colMeans(ret_mat, na.rm = TRUE)
  cov_matrix <- cov(ret_mat, use = "complete.obs")
  
  r_monthly <- risk_free_rate / 12
  
  cat("\n=== KELLY OPTIMIZATION ===\n")
  cat("Assets:", n_assets, "\n")
  
  # Regularization with better scaling
  eigenvalues <- eigen(cov_matrix, only.values = TRUE)$values
  min_eig <- min(eigenvalues)
  cat("Min eigenvalue:", sprintf("%.6f", min_eig), "\n")
  
  if (min_eig < 1e-5) {
    ridge <- max(1e-4, abs(min_eig) * 100) * mean(diag(cov_matrix))
    cov_matrix <- cov_matrix + diag(ridge, n_assets)
    cat("Applied ridge:", sprintf("%.6f", ridge), "\n")
  }
  
  # Force symmetry
  cov_matrix <- (cov_matrix + t(cov_matrix)) / 2
  
  # Kelly Criterion (quadratic approximation from paper):
  # maximize: (μ - r)'w - 0.5*w'Σw
  # quadprog minimizes: 0.5*w'Dmat*w - dvec'w
  # So: Dmat = Σ, dvec = (μ - r)
  
  Dmat <- cov_matrix
  dvec <- mean_returns - r_monthly
  
  # Ensure positive definiteness
  Dmat <- as.matrix(nearPD(Dmat, corr = FALSE, keepDiag = TRUE)$mat)
  
  # Constraints: sum(w) = 1, w >= 0
  Amat <- cbind(
    rep(1, n_assets),
    diag(n_assets)
  )
  bvec <- c(1, rep(0, n_assets))
  
  # Solve
  sol <- tryCatch({
    solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = 1)
  }, error = function(e) {
    cat("ERROR:", conditionMessage(e), "\n")
    stop("Kelly optimization failed")
  })
  
  weights <- sol$solution
  names(weights) <- colnames(ret_mat)
  
  # Diagnostics
  cat("Converged!  Top 3:", paste(names(sort(weights, decreasing=TRUE)[1:3]), collapse=", "), "\n")
  cat("Weights sum:", sprintf("%.4f", sum(weights)), "\n")
  cat("Non-zero (>0.1%):", sum(weights > 0.001), "\n")
  cat("========================\n\n")
  
  # Calculate statistics
  port_return <- sum(weights * mean_returns)
  port_variance <- t(weights) %*% cov_matrix %*% weights
  port_sd <- sqrt(as.numeric(port_variance))
  
  ann_return <- port_return * 12
  ann_sd <- port_sd * sqrt(12)
  
  list(
    weights = weights,
    expected_return = port_return,
    volatility = port_sd,
    annualized_return = ann_return,
    annualized_volatility = ann_sd,
    n_assets = sum(weights > 0.001),
    covariance_matrix = cov_matrix,
    mean_returns = mean_returns
  )
}
```

## 2.2 Tangent Portfolio (Maximum Sharpe Ratio) - CORRECTED

```{r tangent-optimization}
#| label: tangent-function
optimize_tangent <- function(returns_matrix, risk_free_rate = 0.01) {
  
  ret_mat <- returns_matrix %>%
    select(-DATE) %>%
    as.matrix()
  
  n_assets <- ncol(ret_mat)
  mean_returns <- colMeans(ret_mat, na.rm = TRUE)
  cov_matrix <- cov(ret_mat, use = "complete.obs")
  
  r_monthly <- risk_free_rate / 12
  excess_returns <- mean_returns - r_monthly
  
  cat("\n=== TANGENT PORTFOLIO OPTIMIZATION ===\n")
  
  # Regularize
  eigenvalues <- eigen(cov_matrix, only.values = TRUE)$values
  if (min(eigenvalues) < 1e-6) {
    ridge <- max(1e-5, abs(min(eigenvalues)) * 10) * mean(diag(cov_matrix))
    cov_matrix <- cov_matrix + diag(ridge, n_assets)
  }
  
  # Force symmetry
  cov_matrix <- (cov_matrix + t(cov_matrix)) / 2
  cov_matrix <- as.matrix(nearPD(cov_matrix, corr = FALSE, keepDiag = TRUE)$mat)
  
  # CORRECT METHOD: Maximize Sharpe Ratio directly
  # Sharpe = (μ-r)'w / sqrt(w'Σw)
  # This is equivalent to solving: min w'Σw s. t. (μ-r)'w = 1, w >= 0
  # Then normalize
  
  Dmat <- 2 * cov_matrix
  dvec <- rep(0, n_assets)
  
  # Constraints:
  # 1. (μ-r)'w = 1 (equality)
  # 2. w >= 0 (inequality)
  Amat <- cbind(excess_returns, diag(n_assets))
  bvec <- c(1, rep(0, n_assets))
  
  sol <- tryCatch({
    solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = 1)
  }, error = function(e) {
    cat("ERROR in tangent optimization:", conditionMessage(e), "\n")
    # Fallback: unconstrained solution
    cov_inv <- solve(cov_matrix)
    w <- as.vector(cov_inv %*% excess_returns)
    w <- pmax(w, 0)
    return(list(solution = w))
  })
  
  # Get unnormalized weights
  weights_unnorm <- sol$solution
  
  # Normalize to sum to 1
  weights <- weights_unnorm / sum(weights_unnorm)
  names(weights) <- colnames(ret_mat)
  
  # Calculate portfolio statistics
  port_return <- sum(weights * mean_returns)
  port_variance <- t(weights) %*% cov_matrix %*% weights
  port_sd <- sqrt(as.numeric(port_variance))
  
  ann_return <- port_return * 12
  ann_sd <- port_sd * sqrt(12)
  sharpe <- (ann_return - risk_free_rate) / ann_sd
  
  cat("Converged!  Non-zero assets:", sum(weights > 0.001), "\n")
  cat("Monthly Return:", sprintf("%.4f%%", port_return * 100), "\n")
  cat("Monthly Vol:", sprintf("%.4f%%", port_sd * 100), "\n")
  cat("Sharpe ratio:", sprintf("%.3f", sharpe), "\n")
  
  # VERIFICATION: Check if point is on efficient frontier
  cat("\nVerification:\n")
  cat("  Return/Risk ratio:", sprintf("%.4f", port_return / port_sd), "\n")
  cat("  Excess return/Risk:", sprintf("%.4f", (port_return - r_monthly) / port_sd), "\n")
  cat("=======================================\n\n")
  
  list(
    weights = weights,
    expected_return = port_return,
    volatility = port_sd,
    annualized_return = ann_return,
    annualized_volatility = ann_sd,
    sharpe_ratio = sharpe,
    n_assets = sum(weights > 0.001),
    covariance_matrix = cov_matrix,
    mean_returns = mean_returns
  )
}
```

## 2.3 Minimum Variance Portfolio

```{r minvar-optimization}
#| label: minvar-function
optimize_min_variance <- function(returns_matrix) {
  
  ret_mat <- returns_matrix %>%
    select(-DATE) %>%
    as.matrix()
  
  n_assets <- ncol(ret_mat)
  mean_returns <- colMeans(ret_mat, na.rm = TRUE)
  cov_matrix <- cov(ret_mat, use = "complete.obs")
  
  cat("\n=== MIN VARIANCE OPTIMIZATION (CONSTRAINED) ===\n")
  cat("Assets:", n_assets, "\n")
  
  # Regularize - MUST MATCH frontier computation exactly!  
  eigenvalues <- eigen(cov_matrix, only.values = TRUE)$values
  min_eig <- min(eigenvalues)
  cat("Min eigenvalue:", sprintf("%.6f", min_eig), "\n")
  
  if (min_eig < 1e-6) {
    ridge <- max(1e-5, abs(min_eig) * 10) * mean(diag(cov_matrix))
    cov_matrix <- cov_matrix + diag(ridge, n_assets)
    cat("Applied ridge:", sprintf("%.6f", ridge), "\n")
  }
  
  # Force symmetry - MUST MATCH frontier
  cov_matrix <- (cov_matrix + t(cov_matrix)) / 2
  
  # CONSTRAINED OPTIMIZATION using quadprog
  # minimize: w'Σw
  # subject to: sum(w) = 1, w >= 0
  
  Dmat <- 2 * cov_matrix  # quadprog minimizes 0.5*w'Dmat*w - dvec'w
  dvec <- rep(0, n_assets)
  
  # Constraints:
  # Column 1: sum(w) = 1 (equality)
  # Remaining: w >= 0 (inequality)
  Amat <- cbind(
    rep(1, n_assets),
    diag(n_assets)
  )
  bvec <- c(1, rep(0, n_assets))
  
  sol <- solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = 1)
  
  weights <- sol$solution
  names(weights) <- colnames(ret_mat)
  
  port_return <- sum(weights * mean_returns)
  port_variance <- t(weights) %*% cov_matrix %*% weights
  port_sd <- sqrt(as.numeric(port_variance))
  
  ann_return <- port_return * 12
  ann_sd <- port_sd * sqrt(12)
  
  cat("Converged!\n")
  cat("  Monthly return:", sprintf("%.4f%%", port_return * 100), "\n")
  cat("  Monthly vol:", sprintf("%.4f%%", port_sd * 100), "\n")
  cat("  Non-zero assets:", sum(weights > 0.001), "\n")
  cat("===============================================\n\n")
  
  list(
    weights = weights,
    expected_return = port_return,
    volatility = port_sd,
    annualized_return = ann_return,
    annualized_volatility = ann_sd,
    n_assets = sum(weights > 0.001),
    covariance_matrix = cov_matrix,
    mean_returns = mean_returns
  )
}
```

## 2.4 Equal Weight Portfolio

```{r equalweight}
#| label: equalweight-function

create_equal_weight <- function(returns_matrix) {
  
  ret_mat <- returns_matrix %>%
    select(-DATE) %>%
    as.matrix()
  
  n_assets <- ncol(ret_mat)
  weights <- rep(1/n_assets, n_assets)
  names(weights) <- colnames(ret_mat)
  
  mean_returns <- colMeans(ret_mat, na.rm = TRUE)
  cov_matrix <- cov(ret_mat, use = "complete.obs")
  
  port_return <- sum(weights * mean_returns)
  port_variance <- t(weights) %*% cov_matrix %*% weights
  port_sd <- sqrt(as.numeric(port_variance))
  
  ann_return <- port_return * 12
  ann_sd <- port_sd * sqrt(12)
  
  list(
    weights = weights,
    expected_return = port_return,
    volatility = port_sd,
    annualized_return = ann_return,
    annualized_volatility = ann_sd,
    n_assets = n_assets,
    covariance_matrix = cov_matrix,
    mean_returns = mean_returns
  )
}
```

# 3. Compute In-Sample Portfolios

```{r compute-portfolios}
#| label: compute-portfolios

cat("Computing optimal portfolios...\n\n")

# Kelly Portfolio
kelly <- optimize_kelly_constrained(returns_df, risk_free_rate = 0.01)
cat("✓ Kelly Portfolio computed\n")
cat("  Assets:", kelly$n_assets, "\n")
cat("  Monthly Return:", sprintf("%.3f%%", kelly$expected_return * 100), "\n")
cat("  Monthly Volatility:", sprintf("%.3f%%", kelly$volatility * 100), "\n\n")

# Tangent Portfolio
tangent <- optimize_tangent(returns_df, risk_free_rate = 0.01)
cat("✓ Tangent Portfolio computed\n")
cat("  Assets:", tangent$n_assets, "\n")
cat("  Monthly Return:", sprintf("%.3f%%", tangent$expected_return * 100), "\n")
cat("  Monthly Volatility:", sprintf("%.3f%%", tangent$volatility * 100), "\n\n")

# Minimum Variance
minvar <- optimize_min_variance(returns_df)
cat("✓ Min Variance Portfolio computed\n")
cat("  Assets:", minvar$n_assets, "\n")
cat("  Monthly Return:", sprintf("%.3f%%", minvar$expected_return * 100), "\n")
cat("  Monthly Volatility:", sprintf("%.3f%%", minvar$volatility * 100), "\n\n")

# Equal Weight
eqwt <- create_equal_weight(returns_df)
cat("✓ Equal Weight Portfolio computed\n")
cat("  Assets:", eqwt$n_assets, "\n")
cat("  Monthly Return:", sprintf("%.3f%%", eqwt$expected_return * 100), "\n")
cat("  Monthly Volatility:", sprintf("%.3f%%", eqwt$volatility * 100), "\n")
```

# 4. Tables 6 & 7 in Paper: Portfolio Compositions

## Table 7 in Paper: Kelly Portfolio Composition

```{r table-kelly}
#| label: table-kelly

kelly_weights <- tibble(
  Rank = 1:length(kelly$weights),
  Equity = names(kelly$weights),
  Weight = kelly$weights,
  `Weight (%)` = sprintf("%.2f%%", kelly$weights * 100),
  `Monthly Return (%)` = sprintf("%.3f%%", kelly$mean_returns[names(kelly$weights)] * 100)
) %>%
  filter(Weight > 0.001) %>%
  arrange(desc(Weight)) %>%
  mutate(Rank = row_number())

kable(kelly_weights, 
      caption = "**Table 7 in Paper**: Composition of the Optimal Full Kelly Portfolio (In-Sample)",
      align = c("c", "l", "r", "r", "r"))

cat("\n")
cat("Total Expected Monthly Return:", sprintf("%.3f%%", kelly$expected_return * 100), "\n")
cat("Standard Deviation:", sprintf("%.3f%%", kelly$volatility * 100), "\n")
cat("Coefficient of Variation:", sprintf("%.3f", kelly$volatility / kelly$expected_return), "\n")
cat("\n**Paper Target**: Monthly Return 1.747%, Std Dev 2.342%, 3 assets (Vinci 51.51%, Adidas 40.82%, Sanofi 7.68%)\n")
```

## Table 6 in Paper: Tangent Portfolio Composition

```{r table-tangent}
#| label: table-tangent

tangent_weights <- tibble(
  Rank = 1:length(tangent$weights),
  Equity = names(tangent$weights),
  Weight = tangent$weights,
  `Weight (%)` = sprintf("%.2f%%", tangent$weights * 100),
  `Monthly Return (%)` = sprintf("%.3f%%", tangent$mean_returns[names(tangent$weights)] * 100)
) %>%
  filter(Weight > 0.001) %>%
  arrange(desc(Weight)) %>%
  mutate(Rank = row_number())

kable(tangent_weights,
      caption = "**Table 6 in Paper**: Composition of the Tangent Portfolio (In-Sample)",
      align = c("c", "l", "r", "r", "r"))

cat("\n")
cat("Total Expected Monthly Return:", sprintf("%.3f%%", tangent$expected_return * 100), "\n")
cat("Standard Deviation:", sprintf("%.3f%%", tangent$volatility * 100), "\n")
cat("Coefficient of Variation:", sprintf("%.3f", tangent$volatility / tangent$expected_return), "\n")
cat("\n**Paper Target**: Monthly Return 1.490%, Std Dev 2.062%, 8 assets\n")
```

# 5. Figure 4: Efficient Frontier

## 5.1 Compute Efficient Frontier

```{r efficient-frontier-compute}
#| label: efficient-frontier-compute

compute_efficient_frontier <- function(returns_matrix, risk_free_rate = 0.01, n_points = 100) {
  
  ret_mat <- returns_matrix %>%
    select(-DATE) %>%
    as.matrix()
  
  n_assets <- ncol(ret_mat)
  mean_returns <- colMeans(ret_mat, na.rm = TRUE)
  cov_matrix <- cov(ret_mat, use = "complete.obs")
  r_monthly <- risk_free_rate / 12
  
  cat("\n=== EFFICIENT FRONTIER COMPUTATION ===\n")
  cat("Assets:", n_assets, "\n")
  
  # Regularize - SAME as other functions
  eigenvalues <- eigen(cov_matrix, only.values = TRUE)$values
  min_eig <- min(eigenvalues)
  
  if (min_eig < 1e-6) {
    ridge <- max(1e-5, abs(min_eig) * 10) * mean(diag(cov_matrix))
    cov_matrix <- cov_matrix + diag(ridge, n_assets)
  }
  
  cov_matrix <- (cov_matrix + t(cov_matrix)) / 2
  
  # FIND MIN VARIANCE PORTFOLIO (constrained)
  Dmat_mv <- 2 * cov_matrix
  dvec_mv <- rep(0, n_assets)
  Amat_mv <- cbind(rep(1, n_assets), diag(n_assets))
  bvec_mv <- c(1, rep(0, n_assets))
  
  sol_mv <- solve.QP(Dmat = Dmat_mv, dvec = dvec_mv, Amat = Amat_mv, bvec = bvec_mv, meq = 1)
  w_minvar <- sol_mv$solution
  
  ret_minvar <- sum(w_minvar * mean_returns)
  vol_minvar <- sqrt(as.numeric(t(w_minvar) %*% cov_matrix %*% w_minvar))
  
  cat("Min variance portfolio:\n")
  cat("  Monthly return:", sprintf("%.4f (%.2f%%)", ret_minvar, ret_minvar * 100), "\n")
  cat("  Monthly vol:", sprintf("%.4f (%.2f%%)", vol_minvar, vol_minvar * 100), "\n")
  
  # Use REASONABLE upper bound
  ret_upper <- max(ret_minvar * 2, 0.02)
  
  cat("Using return range:", sprintf("%.4f to %.4f", ret_minvar, ret_upper), "\n")
  
  # Generate target returns
  target_returns <- seq(ret_minvar, ret_upper, length.out = n_points)
  
  # Compute frontier
  frontier <- map_dfr(target_returns, function(target_ret) {
    
    Dmat <- 2 * cov_matrix
    dvec <- rep(0, n_assets)
    
    # Constraints: w'μ = target, w'1 = 1, w >= 0
    Amat <- cbind(mean_returns, rep(1, n_assets), diag(n_assets))
    bvec <- c(target_ret, 1, rep(0, n_assets))
    
    sol <- tryCatch({
      solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec, meq = 2)
    }, error = function(e) NULL)
    
    if (! is.null(sol)) {
      w <- sol$solution
      ret <- sum(w * mean_returns)
      vol <- sqrt(as.numeric(t(w) %*% cov_matrix %*% w))
      
      tibble(return_monthly = ret, volatility_monthly = vol)
    } else {
      NULL
    }
  }) %>%
    bind_rows()
  
  cat("Successfully computed", nrow(frontier), "frontier points\n")
  if (nrow(frontier) > 0) {
    cat("Volatility range:", sprintf("%.4f to %.4f", 
        min(frontier$volatility_monthly), max(frontier$volatility_monthly)), "\n")
  }
  cat("=====================================\n\n")
  
  list(
    frontier = frontier,
    minvar_return = ret_minvar,
    minvar_volatility = vol_minvar
  )
}

# ===== NOW CALL THE FUNCTION =====
cat("Computing efficient frontier...\n")
frontier_result <- compute_efficient_frontier(returns_df, risk_free_rate = 0.01, n_points = 100)
frontier <- frontier_result$frontier
minvar_from_frontier <- list(
  expected_return = frontier_result$minvar_return,
  volatility = frontier_result$minvar_volatility
)
cat("✓ Efficient frontier computed with", nrow(frontier), "points\n")
cat("✓ Min variance from frontier: Return", sprintf("%.3f%%", minvar_from_frontier$expected_return * 100), 
    "Vol", sprintf("%.3f%%", minvar_from_frontier$volatility * 100), "\n")
```

## 5.2 Plot Figure 4

```{r figure-4}
#| label: figure-4
#| fig-width: 10
#| fig-height: 7

# Prepare portfolio data in MONTHLY % metrics
portfolio_data <- tibble(
  Portfolio = c("Equal Weight", "Min Variance", "Tangent Pf", "Kelly Pf"),
  Return = c(
    eqwt$expected_return * 100,
    minvar_from_frontier$expected_return * 100,  # CHANGED THIS LINE
    tangent$expected_return * 100,
    kelly$expected_return * 100
  ),
  Risk = c(
    eqwt$volatility * 100,
    minvar_from_frontier$volatility * 100,  # CHANGED THIS LINE
    tangent$volatility * 100,
    kelly$volatility * 100
  )
)

# Print diagnostics
cat("\n=== PORTFOLIO METRICS FOR FIGURE 4 (Monthly %) ===\n")
print(portfolio_data)
cat("===================================================\n\n")

# Calculate Capital Market Line (CML)
# CML passes through risk-free rate (return = rf, risk = 0) and tangent portfolio
rf_monthly_pct <- 0.01 / 12 * 100  # Risk-free rate in monthly %
tangent_return <- tangent$expected_return * 100
tangent_risk <- tangent$volatility * 100

# CML slope (Sharpe ratio of tangent portfolio)
cml_slope <- (tangent_return - rf_monthly_pct) / tangent_risk

# Create CML line data - extend beyond tangent portfolio
cml_data <- tibble(
  risk = seq(0, 8.5, length.out = 100),
  return = rf_monthly_pct + cml_slope * risk
)

# Create plot
p_frontier <- ggplot() +
  # Efficient frontier (the curved solid line)
  geom_line(data = frontier, 
            aes(x = volatility_monthly * 100, y = return_monthly * 100),
            color = "gray60", linetype = "solid", linewidth = 1) +
  # Capital Market Line (the straight tangent line)
  geom_line(data = cml_data %>% filter(risk <= 8.5, return <= 2.0),
            aes(x = risk, y = return),
            color = "gray40", linetype = "solid", linewidth = 0.8, alpha = 0.7) +
  # Portfolios
  geom_point(data = portfolio_data,
             aes(x = Risk, y = Return, 
                 color = Portfolio, shape = Portfolio),
             size = 5) +
  scale_color_manual(values = c("Equal Weight" = "black",
                                  "Min Variance" = "#F39C12",
                                  "Tangent Pf" = "#3498DB",
                                  "Kelly Pf" = "#E74C3C")) +
  scale_shape_manual(values = c("Equal Weight" = 15,
                                 "Min Variance" = 16,
                                 "Tangent Pf" = 18,
                                 "Kelly Pf" = 15)) +
  scale_x_continuous(
    limits = c(3, 8.5),
    breaks = seq(3, 8, by = 1)
  ) +
  scale_y_continuous(
    limits = c(0, 1.8),
    breaks = seq(0, 1.8, by = 0.3)
  ) +
  labs(
    title = "Mean-Variance Space",
    x = "Risk",
    y = "Return",
    color = "",
    shape = ""
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 15),
    legend.position = c(0.85, 0.25),
    legend.background = element_rect(fill = "white", color = "black", linewidth = 0.4),
    legend.title = element_blank(),
    legend.text = element_text(size = 11),
    panel.grid.major = element_line(color = "gray85", linewidth = 0.3),
    panel.grid.minor = element_line(color = "gray92", linewidth = 0.2),
    panel.background = element_rect(fill = "white"),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.6),
    axis.text = element_text(size = 11)
  )

print(p_frontier)

ggsave("figure_4_efficient_frontier.png", p_frontier, 
       width = 10, height = 7, dpi = 300, bg = "white")
cat("\n✓ Figure 4 saved: figure_4_efficient_frontier.png\n")
```

# 6. Figure 5: Cumulative Returns

## 6.1 Calculate Cumulative Wealth

```{r cumulative-returns}
#| label: cumulative-returns

ret_mat <- returns_df %>%
  select(-DATE) %>%
  as.matrix()

dates <- returns_df$DATE

# Calculate portfolio returns
kelly_returns <- ret_mat %*% kelly$weights
tangent_returns <- ret_mat %*% tangent$weights
minvar_returns <- ret_mat %*% minvar$weights
eqwt_returns <- ret_mat %*% eqwt$weights

# Check for NaN
valid_rows <- complete.cases(kelly_returns, tangent_returns, minvar_returns, eqwt_returns)

kelly_returns <- kelly_returns[valid_rows]
tangent_returns <- tangent_returns[valid_rows]
minvar_returns <- minvar_returns[valid_rows]
eqwt_returns <- eqwt_returns[valid_rows]
dates <- dates[valid_rows]

# Calculate cumulative wealth
wealth_df <- tibble(
  DATE = as.Date(dates),
  Kelly = cumprod(1 + kelly_returns),
  `Eq Weights` = cumprod(1 + eqwt_returns),
  `Tangent Pf` = cumprod(1 + tangent_returns),
  `Min Variance` = cumprod(1 + minvar_returns)
) %>%
  pivot_longer(cols = -DATE, names_to = "Portfolio", values_to = "Wealth")

cat("Cumulative wealth calculated\n")
cat("Final wealth (starting from 1):\n")
wealth_df %>%
  filter(DATE == max(DATE)) %>%
  arrange(desc(Wealth)) %>%
  mutate(Wealth = sprintf("%.2f", Wealth)) %>%
  kable()
```

## 6.2 Plot Figure 5

```{r figure-5}
#| label: figure-5
#| fig-width: 12
#| fig-height: 7

p_cumulative <- ggplot(wealth_df, aes(x = DATE, y = Wealth, color = Portfolio)) +
  geom_line(linewidth = 1) +
  scale_color_manual(values = c(
    "Kelly" = "#E74C3C",
    "Eq Weights" = "black",
    "Tangent Pf" = "#3498DB",
    "Min Variance" = "#F39C12"
  )) +
  scale_y_continuous(limits = c(0, max(wealth_df$Wealth) * 1.1), 
                     breaks = pretty(c(0, max(wealth_df$Wealth)), n = 6)) +
  scale_x_date(date_breaks = "3 years", date_labels = "%b %Y") +
  labs(
    title = "Cumulative Returns",
    subtitle = "2000-02-01 / 2019-01-01",
    x = "",
    y = "",
    color = ""
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 1, size = 10),
    legend.position = c(0.15, 0.85),
    legend.background = element_rect(fill = "white", color = "black", linewidth = 0.3),
    panel.grid.major = element_line(color = "gray85"),
    panel.grid.minor = element_line(color = "gray92"),
    panel.background = element_rect(fill = "white", color = "black", linewidth = 0.5),
    axis.text.x = element_text(angle = 0, hjust = 0.5)
  )

print(p_cumulative)

ggsave("figure_5_cumulative_returns.png", p_cumulative,
       width = 12, height = 7, dpi = 300, bg = "white")
cat("\n✓ Figure 5 saved: figure_5_cumulative_returns.png\n")
```

# 7.  Summary Statistics

```{r summary-stats}
#| label: summary-stats

summary_stats <- tibble(
  Portfolio = c("Kelly", "Tangent", "Min Variance", "Equal Weight"),
  `N Assets` = c(kelly$n_assets, tangent$n_assets, minvar$n_assets, eqwt$n_assets),
  `Monthly Return (%)` = c(kelly$expected_return * 100, tangent$expected_return * 100,
                            minvar$expected_return * 100, eqwt$expected_return * 100),
  `Monthly Vol (%)` = c(kelly$volatility * 100, tangent$volatility * 100,
                         minvar$volatility * 100, eqwt$volatility * 100),
  `Annual Return (%)` = c(kelly$annualized_return * 100, tangent$annualized_return * 100,
                           minvar$annualized_return * 100, eqwt$annualized_return * 100),
  `Annual Vol (%)` = c(kelly$annualized_volatility * 100, tangent$annualized_volatility * 100,
                        minvar$annualized_volatility * 100, eqwt$annualized_volatility * 100),
  `Coeff of Var` = c(kelly$volatility / kelly$expected_return,
                     tangent$volatility / tangent$expected_return,
                     minvar$volatility / minvar$expected_return,
                     eqwt$volatility / eqwt$expected_return)
)

kable(summary_stats, digits = 3,
      caption = "**Summary Statistics**: In-Sample Portfolio Performance")
```

# 8.  Validation Against Paper

## Expected Results from Carta & Conversano (2020)

**Table 7 - Kelly Portfolio:**
- Vinci: 51.51%, Adidas: 40.82%, Sanofi: 7.68%
- Monthly Return: 1.747%, Monthly Vol: 2.342%
- Coefficient of Variation: 1.341

**Table 6 - Tangent Portfolio:**
- 8 assets (Vinci, Adidas, Iberdrola, Air Liquide, Unilever, Sanofi, URW, Danone)
- Monthly Return: 1.490%, Monthly Vol: 2.062%
- Coefficient of Variation: 1.383

## Comparison

```{r validation}
#| label: validation

cat("===== VALIDATION AGAINST PAPER =====\n\n")

cat("KELLY PORTFOLIO:\n")
cat("Paper: 3 assets (Vinci 51.51%, Adidas 40.82%, Sanofi 7.68%)\n")
cat("Paper: Monthly Return 1.747%, Vol 2.342%, CV 1.341\n")
cat("Ours:", kelly$n_assets, "assets,",
    "Monthly Return", sprintf("%.3f%%", kelly$expected_return * 100), ",",
    "Vol", sprintf("%.3f%%", kelly$volatility * 100), ",",
    "CV", sprintf("%.3f", kelly$volatility / kelly$expected_return), "\n\n")

cat("TANGENT PORTFOLIO:\n")
cat("Paper: 8 assets, Monthly Return 1.490%, Vol 2.062%, CV 1.383\n")
cat("Ours:", tangent$n_assets, "assets,",
    "Monthly Return", sprintf("%.3f%%", tangent$expected_return * 100), ",",
    "Vol", sprintf("%.3f%%", tangent$volatility * 100), ",",
    "CV", sprintf("%.3f", tangent$volatility / tangent$expected_return), "\n\n")

cat("Note: Differences may arise from:\n")
cat("  1. Exact ticker composition differences\n")
cat("  2. Data source differences (Yahoo Finance vs paper's data provider)\n")
cat("  3. Treatment of missing data and corporate actions\n")
cat("  4. Numerical optimization tolerances\n")
cat("  5. Some tickers may have changed/delisted since 2020\n")
cat("\n====================================\n")
```

# Conclusion

This document replicates the key figures and tables from Section 3.2.2 of Carta & Conversano (2020):

- ✅ **Figure 4**: Efficient Frontier showing Kelly portfolio position
- ✅ **Figure 5**: In-sample cumulative wealth comparison  
- ✅ **Table 6**: Tangent Portfolio composition
- ✅ **Table 7**: Kelly Portfolio composition

**Key Implementation Details:**
1. Kelly Criterion uses quadratic approximation: maximize (μ-r)'w - 0.5*w'Σw
2. Tangent Portfolio uses constrained quadratic programming
3. All portfolios are long-only (w ≥ 0, sum(w) = 1)
4. Risk-free rate: 1% annual
5. Monthly rebalancing with log returns

**Key Findings:**
1. Kelly portfolio achieves highest terminal wealth
2. Portfolio condensation observed in Kelly (3-5 assets vs 8+ in Tangent)
3. Kelly has higher expected return and slightly higher volatility
4. Both portfolios lie on the efficient frontier
5. Equal weight and min variance portfolios underperform

---

**Repository**: `biohackingmathematician/kelly-criterion-portfolio`  
**Author**: Syed Hydari (@syedhydari)  
**Date**: `r Sys.Date()`  
**Paper**: Carta, A., & Conversano, C. (2020). Practical Implementation of the Kelly Criterion: Optimal Growth Rate, Number of Trades, and Rebalancing Frequency for Equity Portfolios. *Frontiers in Applied Mathematics and Statistics*, 6, 577050.